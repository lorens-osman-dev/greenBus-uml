---
tags:
  - green_bus-cluster
parent: "[[CLUSTERS/green_bus-cluster/db/prototyping advices/General Rules|General Rules]]"
generation: 4
---
# Don't use auto incrementing integer primary keys 
Why auto-incrementing integers (sequences) can cause problems in distributed systems, and why UUIDs are often a better choice.

## The Problem: Auto-Incrementing Integers and Distributed Systems
- **Auto-Incrementing Integers (Sequences):**
    - In PostgreSQL, you often use `SERIAL` or sequences to generate auto-incrementing integer primary keys.
    - These sequences are typically managed by a single database node.
- **Distributed Systems:**
    - When your application grows, you might need to scale your database horizontally by adding more nodes.
    - This could be for read scaling (read replicas) or write scaling (sharding or partitioning).
- **The Conflict:**
    - If multiple database nodes are generating auto-incrementing integers, you can have collisions (duplicate primary keys).
    - Each node will start its sequence from a different point, but they will eventually overlap.
    - This is a major problem for data integrity.

### Simple Example: E-commerce Order IDs
- **Single Node (OK):**
    - You have a single PostgreSQL database server.
    - Your `orders` table uses a `SERIAL` primary key (`order_id`).
    - Everything works fine.
- **Scaling to Multiple Nodes (Problem):**
    - Your e-commerce platform becomes very popular.
    - You decide to shard your `orders` table across two database nodes.
    - Node 1 and Node 2 both have their own `order_id` sequences.
    - Node 1 creates an order with `order_id = 100`.
    - At the same time, Node 2 creates an order with `order_id = 100`.
    - Now you have two orders with the same primary key, which violates database integrity.

### The Solution: UUIDs (Universally Unique Identifiers)

- **UUIDs:**
    - UUIDs are 128-bit numbers that are designed to be globally unique.
    - They are generated using algorithms that minimize the risk of collisions.
    - PostgreSQL has the `UUID` data type and the `gen_random_uuid()` function.
- **Benefits of UUIDs:**
    - **Global Uniqueness:** UUIDs are virtually guaranteed to be unique across all nodes.
    - **Distributed Systems:** They work seamlessly in distributed environments.
    - **No Central Authority:** No central authority is required to generate UUIDs.
    - **Client Side Generation:** UUID's can even be generated by the client application, before the data is sent to the database.
- **Example (Using UUIDs):**
    SQL
    ```
    CREATE TABLE orders (
        order_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        -- ... other order details
    );
    ```
    - Now, even if you shard your `orders` table, each node will generate unique `order_id` values.

**When to Use UUIDs**

- **Distributed Systems:** When you anticipate scaling your database horizontally.
- **Data Replication:** When you need to replicate data between databases.
- **Data Integration:** When you need to integrate data from multiple sources.
- **Any Situation Where Global Uniqueness Is Required.**

**Important Considerations**

- **Storage Space:** UUIDs take up more storage space than integers (16 bytes vs. 4 bytes).
- **Indexing Performance:** UUIDs can be slightly less efficient for indexing than integers, but this is often negligible.
- **Readability:** UUIDs are less human-readable than integers.